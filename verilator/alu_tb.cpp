#include "Valu.h"        // Generated by Verilator

#include "verilated_vcd_c.h"
#include "verilated.h"
#include <assert.h>
#include <time.h>

#define N_OPERATIONS 20

static const int opcode_array[N_OPERATIONS] = {	0b00000, 0b10000, 0b00111, 0b00110,
												0b00100, 0b01000, 0b01001, 0b01011,
												0b01010, 0b01100, 0b01101, 0b01110,
												0b01111, 0b00001, 0b00101, 0b10101,
												0b00010, 0b00011, 0b11000, 0b11001};

const char *op_format[N_OPERATIONS] = 
{
	"0b%032b + 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b - 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b & 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b | 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b ^ 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b * 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"upper 0b%032b * 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"upper (unsigned) 0b%032b * 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"upper (signed, unsigned) 0b%032b * 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b / 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"(unsigned) 0b%032b / 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b %% 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"(unsigned) 0b%032b %% 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b << 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b >> 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b >>> 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"0b%032b < 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"(unsigned) 0b%032b < 0b%032b = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"\\pi_1(0b%032b, 0b%032b) = 0b%032b    (expected 0b%032b), xor 0b%032b\n",
	"\\pi_2(0b%032b, 0b%032b) = 0b%032b    (expected 0b%032b), xor 0b%032b\n"
};

static uint64_t ticks = 0;
static int good = 1;
VerilatedVcdC* tfp = new VerilatedVcdC;

void tick(Valu* alu)
{
    assert(alu != NULL);

    alu->clock = 0;
	alu->eval();
    if (tfp) tfp->dump(ticks++);

    alu->clock = 1;
	alu->eval();
    if (tfp) tfp->dump(ticks++);
}

int expected_result(int x, int y, int op)
{
	int64_t prod;
	switch (op)
	{
		case 18: 	return x;
		case 19: 	return y;
		case 0: 	return x+y;
		case 1: 	return x-y;
		case 2: 	return x&y;
		case 3:	return x|y;
		case 4:	return x^y;
		case 5:	return (int)(((int64_t)x*(int64_t)y));
		case 6:	return (int)(((int64_t)x*(int64_t)y) >> 32);
		case 7:	return (uint32_t)(((uint64_t)(uint32_t)x * (uint64_t)(uint32_t)y) >> 32);
		case 8:
			prod = (int64_t)x * (uint64_t)(uint32_t)y;
			return (int32_t)(prod >> 32);
			break;
		case 9:		return (y != 0) ? (x / y) : 0xffffffff;
		case 10:	return (y != 0) ? (int)((uint32_t)x / (uint32_t)y) : 0xffffffff;
		case 11:	return (y != 0) ? (x % y) : x;
		case 12:	return (y != 0) ? (int)((uint32_t)x % (uint32_t)y) : x;
		case 13:	return ((uint32_t)y < 32 ? x << (uint32_t)(y & 31) : 0);
		case 14:	return ((uint32_t)y < 32 ? (uint32_t) x >> (y & 31) : (uint32_t)x >> 32);
		case 15:	return ((uint32_t)y < 32 ? x >> (y & 31) : (x < 0) ? -1 : 0);
		case 16:	return x < y;
		case 17:	return (uint32_t)x < (uint32_t)y;
		default: 	assert(false);
	}
}


int sync_op(Valu* alu, int x, int y, int operation)
{
	alu->in1 = x;
	alu->in2 = y;
	alu->operation = opcode_array[operation];
	alu->clock_enable = 1;
	
	uint64_t start_ticks = ticks;

	do {
		tick(alu);
		if (ticks > start_ticks + 64)
		{
			printf("Operation timeout\n");
			good = 0;
			return 0;
		}
	} while (!alu->result_ready);
	
	
	alu->clock_enable = 0;
	tick(alu);
	
	return alu->out_sync;
}

int async_op(Valu* alu, int x, int y, int operation)
{
	alu->in1 = x;
	alu->in2 = y;
	alu->operation = opcode_array[operation];

	alu->eval();
	
	return alu->out_async;
}

int alu_calc(Valu* alu, int x, int y, int op, int sync)
{
	return (sync) ? sync_op(alu, x, y, op) : async_op(alu, x, y, op);
}

#define N_TESTS 64

int main(int argc, char **argv) 
{
	srand(time(0));
	
    Verilated::commandArgs(argc, argv);
    Valu* alu = new Valu;
    
    Verilated::traceEverOn(true);
	alu->trace(tfp, 99);
	tfp->open("verilator/alu.vcd");

	int x, y, r, expected;
	int sync = 0;
	int signs = 0;

	tick(alu);

	for (int op = 0; good && op < N_OPERATIONS; op++)
	{
		alu->operation = opcode_array[op];
		alu->eval();
		
		sync = alu->op_sync;
		for (int signs = 0; signs < 4; signs++)
		{
			for (int flip = 0; flip < 2; flip++)
			{
				for (int i = 0; good && i < N_TESTS; i++)
				{
					if (flip)
						x = (( signs & 1      ) ? (-1) : 1) * (rand() % (0xffffffff >> (int)(32 * (1.0 - (float)(i+2) / (float)N_TESTS))));
					else
						x = (( signs & 1      ) ? (-1) : 1) * (rand() % (0xffffffff >> (int)(32 * (1.0 - (float)((N_TESTS - i)+2) / (float)N_TESTS))));
						
					y = (((signs & 2) >> 1) ? (-1) : 1) * (rand() % (0xffffffff >> (int)(32 * (1.0 - (float)(i+2) / (float)N_TESTS))));
					
					r = alu_calc(alu, x, y, op, sync);
					expected = expected_result(x, y, op);
					
					printf(op_format[op], x, y, r, expected, r ^ expected);
					
					if (r != expected && r == -expected)
						printf("negation!\n");
					
					if (r ^ expected)
						good = 0;
				}
			}
		}
	}
	
	tick(alu);
	tick(alu);
	tick(alu);
	tick(alu);
	tick(alu);
	tick(alu);
	
	if (good)
		printf("All good!\n");
	else
		printf("Incorrect result!\n");
	printf("Ticks at exit: %d\n", ticks);
    
    tfp->close();

    delete alu;
    return 0;
}
