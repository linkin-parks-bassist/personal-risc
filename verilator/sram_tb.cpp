#include "Vsram.h"        // Generated by Verilator

#include "verilated_vcd_c.h"
#include "verilated.h"
#include <assert.h>
#include <time.h>

#define SRAM_COMMAND_NO_CMD 		0
#define SRAM_COMMAND_READ8 			1
#define SRAM_COMMAND_READ16 		3
#define SRAM_COMMAND_READ32 		5
#define SRAM_COMMAND_WRITE8 		2
#define SRAM_COMMAND_WRITE16 		4
#define SRAM_COMMAND_WRITE32 		6

static uint64_t ticks = 0;
static int 		good  = 1;

VerilatedVcdC* tfp = new VerilatedVcdC;

void tick(Vsram *sram)
{
    assert(sram != NULL);

    sram->clock = 0;
	sram->eval();
    if (tfp) tfp->dump(ticks++);

    sram->clock = 1;
	sram->eval();
    if (tfp) tfp->dump(ticks++);
}

void sram_write8(Vsram *sram, uint32_t addr, uint8_t data)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_WRITE8;
	sram->addr_in = addr;
	sram->data_in = (uint32_t)data;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
}

uint32_t sram_read8(Vsram *sram, uint32_t addr)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_READ8;
	sram->addr_in = addr;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
	
	return sram->data_out;
}

void sram_write16(Vsram *sram, uint32_t addr, uint16_t data)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_WRITE16;
	sram->addr_in = addr;
	sram->data_in = (uint32_t)data;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
}

uint32_t sram_read16(Vsram *sram, uint32_t addr)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_READ16;
	sram->addr_in = addr;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
	
	return sram->data_out;
}

void sram_write32(Vsram *sram, uint32_t addr, uint32_t data)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_WRITE32;
	sram->addr_in = addr;
	sram->data_in = (uint32_t)data;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
}

uint32_t sram_read32(Vsram *sram, uint32_t addr)
{
	assert(sram != NULL);
	
	sram->command = SRAM_COMMAND_READ32;
	sram->addr_in = addr;
	
	tick(sram);
	sram->command = SRAM_COMMAND_NO_CMD;
	tick(sram);
	
	return sram->data_out;
}

#define N_BANKS 8
#define WORDS_PER_BANK 512

#define MAX_ADDRESS (N_BANKS * WORDS_PER_BANK)

int main(int argc, char **argv) 
{
	srand(time(0));
	
    Verilated::commandArgs(argc, argv);
    Vsram *sram = new Vsram;
    
    Verilated::traceEverOn(true);
	sram->trace(tfp, 99);
	tfp->open("verilator/sram.vcd");

	tick(sram);
	
	uint32_t ui32_array[MAX_ADDRESS / 4];
	uint32_t read_ui32;
	
	for (uint32_t i = 0; i < MAX_ADDRESS / 4; i++)
	{
		ui32_array[i] = (uint32_t)rand();
		sram_write32(sram, 4 * i, ui32_array[i]);
		printf("Wrote word 0b%032b at address 0x%08x...\n", ui32_array[i], 4 * i);
	}
	 
	for (uint32_t i = 0; good & 4 * i < MAX_ADDRESS; i++)
	{
		read_ui32 = (uint32_t)sram_read32(sram, 4 * i);
		
		printf("Read word 0b%032b from address 0x%08x...\n", read_ui32, 4 * i);
		if (read_ui32 != ui32_array[i])
		{
			printf("MISMATCH DETECTED; expected 0b%032b\n", ui32_array[i]);
			good = 0;
		}
	}
	
	uint16_t ui16_array[MAX_ADDRESS / 2];
	uint16_t read_ui16;
	
	for (uint32_t i = 0; i < MAX_ADDRESS / 2; i++)
	{
		ui16_array[i] = (uint16_t)rand();
		sram_write16(sram, 2 * i, ui16_array[i]);
		printf("Wrote short 0b%016b at address 0x%08x...\n", ui16_array[i], 2 * i);
	}
	 
	for (uint32_t i = 0; good & 2 * i < MAX_ADDRESS; i++)
	{
		read_ui16 = (uint16_t)sram_read16(sram, 2 * i);
		
		printf("Read short 0b%016b from address 0x%08x...\n", read_ui16, 2 * i);
		if (read_ui16 != ui16_array[i])
		{
			printf("MISMATCH DETECTED; expected 0b%016b\n", ui32_array[i]);
			good = 0;
		}
	}
	
	uint8_t ui8_array[MAX_ADDRESS / 1];
	uint8_t read_ui8;
	
	for (uint32_t i = 0; i < MAX_ADDRESS / 1; i++)
	{
		ui8_array[i] = (uint8_t)rand();
		sram_write8(sram, 1 * i, ui8_array[i]);
		printf("Wrote byte 0b%08b at address 0x%08x...\n", ui8_array[i], 1 * i);
	}
	 
	for (uint32_t i = 0; good & 1 * i < MAX_ADDRESS; i++)
	{
		read_ui8 = (uint8_t)sram_read8(sram, 1 * i);
		
		printf("Read byte 0b%08b from address 0x%08x...\n", read_ui8, 1 * i);
		if (read_ui8 != ui8_array[i])
		{
			printf("MISMATCH DETECTED; expected 0b%08b\n", ui8_array[i]);
			good = 0;
		}
	}
	
	tick(sram);
	tick(sram);
	tick(sram);
	tick(sram);
	tick(sram);
	tick(sram);
	
	if (good)
		printf("All good!\n");
	else
		printf("Incorrect result!\n");
	printf("Ticks at exit: %d\n", ticks);
    
    tfp->close();

    delete sram;
    return 0;
}
